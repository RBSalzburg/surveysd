#' recalib
#'
#' @title Calibrate weights
#'
#' @description Calibrate weights for bootstrap replicates by using iterative proportional updating to match population totals on various household and personal levels.
#'
#' @usage recalib(dat,hid="hid",weights="hgew",b.rep=paste0("w",1:1000),year="jahr",
#'                conP.var=c("ksex","kausl","al","erw","pension"),
#'                conH.var=c("bundesld","hsize","recht"),...)
#'
#' @param dat either data.frame or data.table containing the sample survey for various years.
#' @param hid string specifying the name of the column in \code{dat} containing the household ID.
#' @param weights string specifying the name of the column in \code{dat} containing the sample weights.
#' @param b.rep string specifying the names of the columns in \code{dat} containing bootstrap weights which should be recalibratet
#' @param year string specifying the name of the column in \code{dat} containing the sample years.
#' @param conP.var character vector containig person-specific variables to which weights should be calibrated. for which contingency tables for the population tables are calculatet per \code{year} and
#' @param conH.var character vector containig household-specific variables to which weights should be calibrated.
#' @param ... additional arguments passed on to function \code{\link[simpPop]{ipu2}} from the \code{simPop} package.
#'
#'
#' @details \code{recalib} takes survey data (\code{dat}) containing the bootstrap replicates generated by \code{\link{bootstrap.rep}} and calibrates weights for each bootstrap
#' replication according to population totals for person- or household-specific variables. \cr
#' \code{dat} should contain household survey data, where each row corresponds to one household, and which contains at least the following columns
#' \itemize{
#'   \item Column indicating the sample year;
#'   \item Column indicating the household ID;
#'   \item Column containing the household sample weights;
#'   \item Columns which contain the bootstrap replicates (see output of \code{\link{bootstrap.rep}});
#'   \item Columns indicating person- or household-specific variables for which sample weight should be adjusted.
#' }
#' For each year and each variable in \code{conP.var} and/or \code{conH.var} contingency tables are estimated to get margin totals on personal- and/or household-specific variables in the population.\cr
#' Afterwards the bootstrap replicates are multiplied with the original sample weight and the resulting product ist then adjusted using \code{\link[simpPop]{ipu2}} to match the previously calcualted contingency tables.
#' In this process the columns of the bootstrap replicates are overwritten by the calibrated weights.\cr
#'
#' @return Returns a data.table containing the survey data as well as the calibrated weights for the bootstrap replicates, which are labeled like the bootstrap replicates.
#'
#' @seealso \code{\link[simpPop]{ipu2}} for more information on iterative proportional fitting.
#'
#' @author Johannes Gussenbauer, Alexander Kowarik, Statistics Austria
#'
#' @examples
#' # read in data (need to be changed)
#' library(data.table)
#' dat <- data.table(read_sas("O:/B/3-AP/Analyse/sonstiges/
#'                             bundesländerschätzungen 2008-2018/daten/bldaten0816.sas7bdat"))
#' # draw bootstrap replicates
#' dat <- bootstrap.rep(dat,REP=20,hid="hid",weights="hgew",
#'                      strata="bundesld",year="jahr",totals=NULL,boot.names=NULL)
#'
#' # calibrate weight for bootstrap replicates
#' # use sex for person-specific and hsize for household-specific marginals
#' dat_calib <- recalib(dat=copy(dat),hid="hid",weights="hgew",b.weights=paste0("w",1:20),
#'                      year="jahr",conP.var=c("sex"),conH.var=c("hsize"))
#'
#'
#' # do the same but expand person- and household specific variables
#' dat_calib <- recalib(dat=copy(dat),hid="hid",weights="hgew",b.weights=paste0("w",1:20),
#'                      year="jahr",conP.var=c("sex","ageX"),conH.var=c("bundesld","hsize"))
#'
#'
#' # for many variables (household- or person-specific)
#' # use increase maxIter to get convergence
#' dat_calib <- recalib(dat=copy(dat),hid="hid",weights="hgew",b.weights=paste0("w",1:20),
#'                      year="jahr",conP.var=c("ksex","age","bildung","kausl","al","erw","pension"),
#'                      conH.var=c("bundesld","hsize","recht"),maxIter=100)
#'
#' @export recalib
#'

recalib <- function(dat,hid="hid",weights="hgew",b.rep=paste0("w",1:1000),year="jahr",conP.var=c("ksex","kausl","al","erw","pension"),
										conH.var=c("bundesld","hsize","recht"),...){

	# define default values for
  ellipsis <- list(...)
  ellipsis[["verbose"]] <- getEllipsis("verbose",TRUE,ellipsis)
  ellipsis[["epsP"]] <- getEllipsis("epsP",1e-2,ellipsis)
  ellipsis[["epsH"]] <- getEllipsis("epsH",5e-2,ellipsis)
  ellipsis[["bound"]] <- getEllipsis("bound",4,ellipsis)
  ellipsis[["maxIter"]] <- getEllipsis("maxIter",50,ellipsis)
  ellipsis[["meanHH"]] <- getEllipsis("meanHH",TRUE,ellipsis)

  eval(parse(text=paste(names(ellipsis),unlist(lapply(ellipsis,as.character)),sep="<-")))

	# calculate contingency tables
	if(!is.null(conP.var)){
		conP <- lapply(conP.var,function(z){
			form.z <- paste0("V1~",paste(year,z,sep="+"))
			dt.eval("xtabs(",form.z,",data=dat[,sum(",weights,"),by=list(",year,",",z,")])")
		})
	}else{
		conP <- NULL
	}
	if(!is.null(conH.var)){

		dat[,ind_p:=c(1L,rep(0,.N-1)),by=c(hid,year)]

		conH <- lapply(conH.var,function(z){
			form.z <- paste0("V1~",paste(year,z,sep="+"))
			dt.eval("xtabs(",form.z,",data=dat[,sum(ind_p*",weights,"),by=list(",year,",",z,")])")
		})
	}else{
		conH <- NULL
	}


	# define new Index
	new_id <- paste(hid,year,sep=",")
	dt.eval("dat[,hidf:=paste0(",new_id,")]")

	# calibrate weights to conP and conH
	select.var <- c("hidf",weights,year,conP.var,conH.var)
	for(g in b.rep){
		set(dat,j=g,value=dt.eval("dat[,",g,"*",weights,"]"))
		set(dat,j=g,value=ipu2(dat=copy(dat[,mget(c(g,select.var))]),conP=conP,
										 conH=conH,verbose=verbose,epsP=epsP,epsH=epsH,
										 w=g,bound=bound,maxIter=maxIter,meanHH=,meanHH,hid="hidf")[,calibWeight])
	}

	return(dat)
}

